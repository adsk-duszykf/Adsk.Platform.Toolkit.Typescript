/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { type AdditionalDataHolder, type BaseRequestBuilder, type Guid, type Parsable, type ParsableFactory, type ParseNode, type RequestConfiguration, type RequestInformation, type RequestsMetadata, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UsersImportPostRequestBody_users_products}
 */
// @ts-ignore
export function createUsersImportPostRequestBody_users_productsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUsersImportPostRequestBody_users_products;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UsersImportPostRequestBody_users}
 */
// @ts-ignore
export function createUsersImportPostRequestBody_usersFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUsersImportPostRequestBody_users;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UsersImportPostRequestBody}
 */
// @ts-ignore
export function createUsersImportPostRequestBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUsersImportPostRequestBody;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UsersImportPostResponse}
 */
// @ts-ignore
export function createUsersImportPostResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUsersImportPostResponse;
}
/**
 * The deserialization information for the current model
 * @param UsersImportPostRequestBody The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUsersImportPostRequestBody(usersImportPostRequestBody: Partial<UsersImportPostRequestBody> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "users": n => { usersImportPostRequestBody.users = n.getCollectionOfObjectValues<UsersImportPostRequestBody_users>(createUsersImportPostRequestBody_usersFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param UsersImportPostRequestBody_users The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUsersImportPostRequestBody_users(usersImportPostRequestBody_users: Partial<UsersImportPostRequestBody_users> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "companyId": n => { usersImportPostRequestBody_users.companyId = n.getStringValue(); },
        "email": n => { usersImportPostRequestBody_users.email = n.getStringValue(); },
        "firstName": n => { usersImportPostRequestBody_users.firstName = n.getStringValue(); },
        "lastName": n => { usersImportPostRequestBody_users.lastName = n.getStringValue(); },
        "products": n => { usersImportPostRequestBody_users.products = n.getCollectionOfObjectValues<UsersImportPostRequestBody_users_products>(createUsersImportPostRequestBody_users_productsFromDiscriminatorValue); },
        "roleIds": n => { usersImportPostRequestBody_users.roleIds = n.getCollectionOfPrimitiveValues<string>(); },
        "userId": n => { usersImportPostRequestBody_users.userId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UsersImportPostRequestBody_users_products The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUsersImportPostRequestBody_users_products(usersImportPostRequestBody_users_products: Partial<UsersImportPostRequestBody_users_products> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "access": n => { usersImportPostRequestBody_users_products.access = n.getEnumValue<UsersImportPostRequestBody_users_products_access>(UsersImportPostRequestBody_users_products_accessObject); },
        "key": n => { usersImportPostRequestBody_users_products.key = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param UsersImportPostResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoUsersImportPostResponse(usersImportPostResponse: Partial<UsersImportPostResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "jobId": n => { usersImportPostResponse.jobId = n.getGuidValue(); },
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UsersImportPostRequestBody The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUsersImportPostRequestBody(writer: SerializationWriter, usersImportPostRequestBody: Partial<UsersImportPostRequestBody> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!usersImportPostRequestBody || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<UsersImportPostRequestBody_users>("users", usersImportPostRequestBody.users, serializeUsersImportPostRequestBody_users);
    writer.writeAdditionalData(usersImportPostRequestBody.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UsersImportPostRequestBody_users The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUsersImportPostRequestBody_users(writer: SerializationWriter, usersImportPostRequestBody_users: Partial<UsersImportPostRequestBody_users> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!usersImportPostRequestBody_users || isSerializingDerivedType) { return; }
    writer.writeStringValue("companyId", usersImportPostRequestBody_users.companyId);
    writer.writeStringValue("email", usersImportPostRequestBody_users.email);
    writer.writeStringValue("firstName", usersImportPostRequestBody_users.firstName);
    writer.writeStringValue("lastName", usersImportPostRequestBody_users.lastName);
    writer.writeCollectionOfObjectValues<UsersImportPostRequestBody_users_products>("products", usersImportPostRequestBody_users.products, serializeUsersImportPostRequestBody_users_products);
    writer.writeCollectionOfPrimitiveValues<string>("roleIds", usersImportPostRequestBody_users.roleIds);
    writer.writeStringValue("userId", usersImportPostRequestBody_users.userId);
    writer.writeAdditionalData(usersImportPostRequestBody_users.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UsersImportPostRequestBody_users_products The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUsersImportPostRequestBody_users_products(writer: SerializationWriter, usersImportPostRequestBody_users_products: Partial<UsersImportPostRequestBody_users_products> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!usersImportPostRequestBody_users_products || isSerializingDerivedType) { return; }
    writer.writeEnumValue<UsersImportPostRequestBody_users_products_access>("access", usersImportPostRequestBody_users_products.access);
    writer.writeStringValue("key", usersImportPostRequestBody_users_products.key);
    writer.writeAdditionalData(usersImportPostRequestBody_users_products.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param UsersImportPostResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeUsersImportPostResponse(writer: SerializationWriter, usersImportPostResponse: Partial<UsersImportPostResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!usersImportPostResponse || isSerializingDerivedType) { return; }
    writer.writeGuidValue("jobId", usersImportPostResponse.jobId);
    writer.writeAdditionalData(usersImportPostResponse.additionalData);
}
export interface UsersImportPostRequestBody extends AdditionalDataHolder, Parsable {
    /**
     * User data to import.
     */
    users?: UsersImportPostRequestBody_users[] | null;
}
export interface UsersImportPostRequestBody_users extends AdditionalDataHolder, Parsable {
    /**
     * The ID of the company that the user is representing in the project. To obtain a list of all company IDs associated with a project, call `GET projects/:projectId/companies </en/docs/acc/v1/reference/http/projects-:project_id-companies-GET/>`_.
     */
    companyId?: string | null;
    /**
     * The email of the user.Max length: 255
     */
    email?: string | null;
    /**
     * The first name of the user.Max length: 255
     */
    firstName?: string | null;
    /**
     * The last name of the user.Max length: 255
     */
    lastName?: string | null;
    /**
     * Information about the products activated in the specified project for this imported user.
     */
    products?: UsersImportPostRequestBody_users_products[] | null;
    /**
     * A list of the IDs of the user's roles in the project.To obtain role IDs for this parameter, you can call `GET projects/:projectId/users </en/docs/acc/v1/reference/http/admin-projects-projectId-users-GET/>`_ endpoint or `GET projects/:projectId/users/:userId </en/docs/acc/v1/reference/http/admin-projects-projectId-users-userId-GET/>`_ and inspect the ``roleId`` field in the response.
     */
    roleIds?: string[] | null;
    /**
     * Not relevant
     */
    userId?: string | null;
}
export interface UsersImportPostRequestBody_users_products extends AdditionalDataHolder, Parsable {
    /**
     * The user's type of access to the product identified by ``key``. Possible values:- ``administrator``- ``member``- ``none``Note that when you're using a POST or PATCH endpoint to set this value, you must adhere to the following guidelines:- If you set a product's ``key`` to ``projectAdministration`` and you set ``access`` to ``none``, all other products should be set to ``member`` access for the user.- If you set a product's ``key`` to ``projectAdministration`` and you set ``access`` to ``administrator``, all other products should be set to ``administrator`` access for the user.- You cannot set a product's ``key`` to ``projectAdministration`` and set ``access`` to ``member``.
     */
    access?: UsersImportPostRequestBody_users_products_access | null;
    /**
     * A keyword that identifies the product.Possible values: ``autoSpecs``, ``build``, ``cost``, ``designCollaboration``, ``docs``, ``insight``, ``modelCoordination``, ``projectAdministration``, and ``takeoff``.
     */
    key?: string | null;
}
export type UsersImportPostRequestBody_users_products_access = (typeof UsersImportPostRequestBody_users_products_accessObject)[keyof typeof UsersImportPostRequestBody_users_products_accessObject];
export interface UsersImportPostResponse extends AdditionalDataHolder, Parsable {
    /**
     * We don't currently support this field, but expect to in a future release.If the response returns ``jobId`` with a valid UUID value, the user import operation was successful.
     */
    jobId?: Guid | null;
}
/**
 * Builds and executes requests for operations under /construction/admin/v2/projects/{projectId}/users:import
 */
export interface UsersImportRequestBuilder extends BaseRequestBuilder<UsersImportRequestBuilder> {
    /**
     * Adds multiple users to a project at once. Can add up to 200 users per request.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<UsersImportPostResponse>}
     */
     post(body: UsersImportPostRequestBody, requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<UsersImportPostResponse | undefined>;
    /**
     * Adds multiple users to a project at once. Can add up to 200 users per request.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toPostRequestInformation(body: UsersImportPostRequestBody, requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
}
/**
 * Uri template for the request builder.
 */
export const UsersImportRequestBuilderUriTemplate = "{+baseurl}/construction/admin/v2/projects/{projectId}/users:import";
/**
 * The user's type of access to the product identified by ``key``. Possible values:- ``administrator``- ``member``- ``none``Note that when you're using a POST or PATCH endpoint to set this value, you must adhere to the following guidelines:- If you set a product's ``key`` to ``projectAdministration`` and you set ``access`` to ``none``, all other products should be set to ``member`` access for the user.- If you set a product's ``key`` to ``projectAdministration`` and you set ``access`` to ``administrator``, all other products should be set to ``administrator`` access for the user.- You cannot set a product's ``key`` to ``projectAdministration`` and set ``access`` to ``member``.
 */
export const UsersImportPostRequestBody_users_products_accessObject = {
    Key: "key",
    Administrator: "administrator",
    Member: "member",
    None: "none",
    ProjectAdministration: "projectAdministration",
    Access: "access",
} as const;
/**
 * Metadata for all the requests in the request builder.
 */
export const UsersImportRequestBuilderRequestsMetadata: RequestsMetadata = {
    post: {
        uriTemplate: UsersImportRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        adapterMethodName: "send",
        responseBodyFactory:  createUsersImportPostResponseFromDiscriminatorValue,
        requestBodyContentType: "application/json",
        requestBodySerializer: serializeUsersImportPostRequestBody,
        requestInformationContentSetMethod: "setContentFromParsable",
    },
};
/* tslint:enable */
/* eslint-enable */
