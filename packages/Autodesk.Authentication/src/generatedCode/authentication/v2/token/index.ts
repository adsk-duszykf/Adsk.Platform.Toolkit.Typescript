/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createAuthTokenFromDiscriminatorValue, createErrorEscapedFromDiscriminatorValue, Granttype, GranttypeObject, serializeAuthToken, type AuthToken, type ErrorEscaped } from '../../../models/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type ApiError, type BaseRequestBuilder, type Parsable, type ParsableFactory, type ParseNode, type RequestConfiguration, type RequestInformation, type RequestsMetadata, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface AuthToken400Error extends AdditionalDataHolder, ApiError, Parsable {
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AuthToken400Error}
 */
// @ts-ignore
export function createAuthToken400ErrorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAuthToken400Error;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TokenPostRequestBody}
 */
// @ts-ignore
export function createTokenPostRequestBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTokenPostRequestBody;
}
/**
 * The deserialization information for the current model
 * @param AuthToken400Error The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAuthToken400Error(authToken400Error: Partial<AuthToken400Error> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
    }
}
/**
 * The deserialization information for the current model
 * @param TokenPostRequestBody The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTokenPostRequestBody(tokenPostRequestBody: Partial<TokenPostRequestBody> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "assertion": n => { tokenPostRequestBody.assertion = n.getStringValue(); },
        "client_id": n => { tokenPostRequestBody.clientId = n.getStringValue(); },
        "code": n => { tokenPostRequestBody.code = n.getStringValue(); },
        "code_verifier": n => { tokenPostRequestBody.codeVerifier = n.getStringValue(); },
        "grant_type": n => { tokenPostRequestBody.grantType = n.getEnumValue<Granttype>(GranttypeObject); },
        "redirect_uri": n => { tokenPostRequestBody.redirectUri = n.getStringValue(); },
        "refresh_token": n => { tokenPostRequestBody.refreshToken = n.getStringValue(); },
        "scope": n => { tokenPostRequestBody.scope = n.getStringValue(); },
    }
}
/**
 * Serializes information the current object
 * @param AuthToken400Error The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAuthToken400Error(writer: SerializationWriter, authToken400Error: Partial<AuthToken400Error> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!authToken400Error || isSerializingDerivedType) { return; }
    writer.writeAdditionalData(authToken400Error.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TokenPostRequestBody The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTokenPostRequestBody(writer: SerializationWriter, tokenPostRequestBody: Partial<TokenPostRequestBody> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!tokenPostRequestBody || isSerializingDerivedType) { return; }
    writer.writeStringValue("assertion", tokenPostRequestBody.assertion);
    writer.writeStringValue("client_id", tokenPostRequestBody.clientId);
    writer.writeStringValue("code", tokenPostRequestBody.code);
    writer.writeStringValue("code_verifier", tokenPostRequestBody.codeVerifier);
    writer.writeEnumValue<Granttype>("grant_type", tokenPostRequestBody.grantType);
    writer.writeStringValue("redirect_uri", tokenPostRequestBody.redirectUri);
    writer.writeStringValue("refresh_token", tokenPostRequestBody.refreshToken);
    writer.writeStringValue("scope", tokenPostRequestBody.scope);
    writer.writeAdditionalData(tokenPostRequestBody.additionalData);
}
export interface TokenPostRequestBody extends AdditionalDataHolder, Parsable {
    /**
     * Required if `grant_type` is `urn:ietf:params:oauth:grant-type:jwt-bearer`
     */
    assertion?: string | null;
    /**
     * This field is required for public client
     */
    clientId?: string | null;
    /**
     * Required if `grant_type` is `authorization_code`
     */
    code?: string | null;
    /**
     * Required if `grant_type` is `authorization_code` and `code_challenge` was specified in /authorize request
     */
    codeVerifier?: string | null;
    /**
     * Enum for grant types
     */
    grantType?: Granttype | null;
    /**
     * Required if `grant_type` is `authorization_code`
     */
    redirectUri?: string | null;
    /**
     * Required if `grant_type` is `refresh_token`
     */
    refreshToken?: string | null;
    /**
     * Required if `grant_type` is `client_credentials. Scopes must be separated by a space.`
     */
    scope?: string | null;
}
/**
 * Builds and executes requests for operations under /authentication/v2/token
 */
export interface TokenRequestBuilder extends BaseRequestBuilder<TokenRequestBuilder> {
    /**
     * Token endpoint returns access token and refresh token, depending on the request parameters.The endpoint requires Basic Authorization for confidential clients. For public clients, the Authorization Header should not be in the header and `client_id` should be included in the form body.* If `grant_type` is `authorization_code`, it returns 3-legged access token for authorization code grant. * If `grant_type` is `client_credentials`, it returns 2-legged access token for client credentials grant.* If `grant_type` is `refresh_token`, it returns new access token by using the refresh token provided in the request.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<AuthToken>}
     * @throws {AuthToken400Error} error when the service returns a 400 status code
     * @throws {ErrorEscaped} error when the service returns a 401 status code
     * @throws {ErrorEscaped} error when the service returns a 429 status code
     */
     post(body: TokenPostRequestBody, requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<AuthToken | undefined>;
    /**
     * Token endpoint returns access token and refresh token, depending on the request parameters.The endpoint requires Basic Authorization for confidential clients. For public clients, the Authorization Header should not be in the header and `client_id` should be included in the form body.* If `grant_type` is `authorization_code`, it returns 3-legged access token for authorization code grant. * If `grant_type` is `client_credentials`, it returns 2-legged access token for client credentials grant.* If `grant_type` is `refresh_token`, it returns new access token by using the refresh token provided in the request.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toPostRequestInformation(body: TokenPostRequestBody, requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
}
/**
 * Uri template for the request builder.
 */
export const TokenRequestBuilderUriTemplate = "{+baseurl}/authentication/v2/token";
/**
 * Metadata for all the requests in the request builder.
 */
export const TokenRequestBuilderRequestsMetadata: RequestsMetadata = {
    post: {
        uriTemplate: TokenRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            400: createAuthToken400ErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
            401: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            429: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createAuthTokenFromDiscriminatorValue,
        requestBodyContentType: "application/x-www-form-urlencoded",
        requestBodySerializer: serializeTokenPostRequestBody,
        requestInformationContentSetMethod: "setContentFromParsable",
    },
};
/* tslint:enable */
/* eslint-enable */
