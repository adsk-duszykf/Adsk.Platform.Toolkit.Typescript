/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createEntityCollectionFromDiscriminatorValue, createErrorResponseFromDiscriminatorValue, createSearchCriteriaFromDiscriminatorValue, createSortCriteriaFromDiscriminatorValue, serializeEntityCollection, serializeSearchCriteria, serializeSortCriteria, type EntityCollection, type ErrorResponse, type SearchCriteria, type SortCriteria } from '../../models/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BaseRequestBuilder, type Parsable, type ParsableFactory, type ParseNode, type RequestConfiguration, type RequestInformation, type RequestsMetadata, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WithVaultIdAdvancedSearchPostRequestBody}
 */
// @ts-ignore
export function createWithVaultIdAdvancedSearchPostRequestBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWithVaultIdAdvancedSearchPostRequestBody;
}
/**
 * The deserialization information for the current model
 * @param WithVaultIdAdvancedSearchPostRequestBody The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoWithVaultIdAdvancedSearchPostRequestBody(withVaultIdAdvancedSearchPostRequestBody: Partial<WithVaultIdAdvancedSearchPostRequestBody> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "entityTypesToSearch": n => { withVaultIdAdvancedSearchPostRequestBody.entityTypesToSearch = n.getCollectionOfEnumValues<WithVaultIdAdvancedSearchPostRequestBody_entityTypesToSearch>(WithVaultIdAdvancedSearchPostRequestBody_entityTypesToSearchObject); },
        "foldersToSearch": n => { withVaultIdAdvancedSearchPostRequestBody.foldersToSearch = n.getCollectionOfPrimitiveValues<string>(); },
        "searchCriterias": n => { withVaultIdAdvancedSearchPostRequestBody.searchCriterias = n.getCollectionOfObjectValues<SearchCriteria>(createSearchCriteriaFromDiscriminatorValue); },
        "sortCriterias": n => { withVaultIdAdvancedSearchPostRequestBody.sortCriterias = n.getCollectionOfObjectValues<SortCriteria>(createSortCriteriaFromDiscriminatorValue); },
    }
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param WithVaultIdAdvancedSearchPostRequestBody The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeWithVaultIdAdvancedSearchPostRequestBody(writer: SerializationWriter, withVaultIdAdvancedSearchPostRequestBody: Partial<WithVaultIdAdvancedSearchPostRequestBody> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!withVaultIdAdvancedSearchPostRequestBody || isSerializingDerivedType) { return; }
    if(withVaultIdAdvancedSearchPostRequestBody.entityTypesToSearch)
    writer.writeCollectionOfEnumValues<WithVaultIdAdvancedSearchPostRequestBody_entityTypesToSearch>("entityTypesToSearch", withVaultIdAdvancedSearchPostRequestBody.entityTypesToSearch);
    writer.writeCollectionOfPrimitiveValues<string>("foldersToSearch", withVaultIdAdvancedSearchPostRequestBody.foldersToSearch);
    writer.writeCollectionOfObjectValues<SearchCriteria>("searchCriterias", withVaultIdAdvancedSearchPostRequestBody.searchCriterias, serializeSearchCriteria);
    writer.writeCollectionOfObjectValues<SortCriteria>("sortCriterias", withVaultIdAdvancedSearchPostRequestBody.sortCriterias, serializeSortCriteria);
    writer.writeAdditionalData(withVaultIdAdvancedSearchPostRequestBody.additionalData);
}
export interface WithVaultIdAdvancedSearchPostRequestBody extends AdditionalDataHolder, Parsable {
    /**
     * EntityTypes to search. If null or empty value is passed, it will include results from all entity types.
     */
    entityTypesToSearch?: WithVaultIdAdvancedSearchPostRequestBody_entityTypesToSearch[] | null;
    /**
     * URL string array for the folder entities.
     */
    foldersToSearch?: string[] | null;
    /**
     * The search parameters.
     */
    searchCriterias?: SearchCriteria[] | null;
    /**
     * The properties to sort on.
     */
    sortCriterias?: SortCriteria[] | null;
}
export type WithVaultIdAdvancedSearchPostRequestBody_entityTypesToSearch = (typeof WithVaultIdAdvancedSearchPostRequestBody_entityTypesToSearchObject)[keyof typeof WithVaultIdAdvancedSearchPostRequestBody_entityTypesToSearchObject];
/**
 * Builds and executes requests for operations under /vaults/{vaultId}:advanced-search
 */
export interface WithVaultIdAdvancedSearchRequestBuilder extends BaseRequestBuilder<WithVaultIdAdvancedSearchRequestBuilder> {
    /**
     * Advanced Search: Allows the user to search for entities within a specified vault. The search can be customized based on various parameters such as entity types (File, Folder, Item, ChangeOrder), specific folders, and search criteria. Users can also sort the results, limit the search to the latest or released files/items only, and decide whether to include subfolders or full models in the search. The 'vaultId' is required in the path to identify the targeted Vault.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<EntityCollection>}
     * @throws {ErrorResponse} error when the service returns a 400 status code
     * @throws {ErrorResponse} error when the service returns a 401 status code
     * @throws {ErrorResponse} error when the service returns a 403 status code
     */
     post(body: WithVaultIdAdvancedSearchPostRequestBody, requestConfiguration?: RequestConfiguration<WithVaultIdAdvancedSearchRequestBuilderPostQueryParameters> | undefined) : Promise<EntityCollection | undefined>;
    /**
     * Advanced Search: Allows the user to search for entities within a specified vault. The search can be customized based on various parameters such as entity types (File, Folder, Item, ChangeOrder), specific folders, and search criteria. Users can also sort the results, limit the search to the latest or released files/items only, and decide whether to include subfolders or full models in the search. The 'vaultId' is required in the path to identify the targeted Vault.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toPostRequestInformation(body: WithVaultIdAdvancedSearchPostRequestBody, requestConfiguration?: RequestConfiguration<WithVaultIdAdvancedSearchRequestBuilderPostQueryParameters> | undefined) : RequestInformation;
}
/**
 * Advanced Search: Allows the user to search for entities within a specified vault. The search can be customized based on various parameters such as entity types (File, Folder, Item, ChangeOrder), specific folders, and search criteria. Users can also sort the results, limit the search to the latest or released files/items only, and decide whether to include subfolders or full models in the search. The 'vaultId' is required in the path to identify the targeted Vault.
 */
export interface WithVaultIdAdvancedSearchRequestBuilderPostQueryParameters {
    /**
     * Indicates the state of the cursor for pagination. Use this parameter to navigate through paged results
     */
    cursorState?: string;
    /**
     * Specifies the number of results to return per page. Maximum limit is controlled by "Page size conifguration" settingwhich could be updated using ADMS ("Global Setting" -> "Page size conifguration").
     */
    limit?: number;
    /**
     * ``true``: The response will include additional detailed information for each entity. Examples include:- For folders (getFolders), it will return `FolderExtended` instead of `Folder`, which includes additional information such as the parent folder.- For file versions (getFileVersions), it will return `FileVersionExtended` instead of `FileVersion`, which includes extra details like the checkout user ID.- For change orders (getChangeOrders), it will return `ChangeOrderExtended` instead of `ChangeOrder`, which provides further information such as the list of assignees.- For property definitions (getPropertyDefinitions), it will return `PropertyDefinitionExtended` instead of `PropertyDefinition`, which includes extra details like list values.``false``: (Default) The response will include basic information for each entity.
     */
    optionextendedModels?: boolean;
    /**
     * ``true``: (Default) Include only the latest version.``false``: Include all versions.
     */
    optionlatestOnly?: boolean;
    /**
     * The properties that need to be returned. property ids separated by ',', e.g. '1,2,3' 'all' means return all properties.
     */
    optionpropDefIds?: string;
    /**
     * ``true``: Include only versions that are consumable (released) state.``false``: (Default) Include all versions.
     */
    optionreleasedFilesOnly?: boolean;
    /**
     * ``true``: Include only versions that are consumable (released) state.``false``: (Default) Include all versions.
     */
    optionreleasedItemsOnly?: boolean;
    /**
     * ``true``: Search sub-folders of the folders specified in foldersToSearch in the request body.``false``: (Default) Do not search sub-folders of the folders specified in foldersToSearch in the request body.If no folders are specified in foldersToSearch in the request body, then this parameter will not have any effect.
     */
    optionsearchSubFolders?: boolean;
}
/**
 * Uri template for the request builder.
 */
export const WithVaultIdAdvancedSearchRequestBuilderUriTemplate = "{+baseurl}/vaults/{vaultId}:advanced-search{?cursorState*,limit*,option%5BextendedModels%5D*,option%5BlatestOnly%5D*,option%5BpropDefIds%5D*,option%5BreleasedFilesOnly%5D*,option%5BreleasedItemsOnly%5D*,option%5BsearchSubFolders%5D*}";
export const WithVaultIdAdvancedSearchPostRequestBody_entityTypesToSearchObject = {
    File: "File",
    Folder: "Folder",
    Item: "Item",
    ChangeOrder: "ChangeOrder",
} as const;
/**
 * Mapper for query parameters from symbol name to serialization name represented as a constant.
 */
const WithVaultIdAdvancedSearchRequestBuilderPostQueryParametersMapper: Record<string, string> = {
    "optionextendedModels": "option%5BextendedModels%5D",
    "optionlatestOnly": "option%5BlatestOnly%5D",
    "optionpropDefIds": "option%5BpropDefIds%5D",
    "optionreleasedFilesOnly": "option%5BreleasedFilesOnly%5D",
    "optionreleasedItemsOnly": "option%5BreleasedItemsOnly%5D",
    "optionsearchSubFolders": "option%5BsearchSubFolders%5D",
};
/**
 * Metadata for all the requests in the request builder.
 */
export const WithVaultIdAdvancedSearchRequestBuilderRequestsMetadata: RequestsMetadata = {
    post: {
        uriTemplate: WithVaultIdAdvancedSearchRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            400: createErrorResponseFromDiscriminatorValue as ParsableFactory<Parsable>,
            401: createErrorResponseFromDiscriminatorValue as ParsableFactory<Parsable>,
            403: createErrorResponseFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createEntityCollectionFromDiscriminatorValue,
        requestBodyContentType: "application/json",
        requestBodySerializer: serializeWithVaultIdAdvancedSearchPostRequestBody,
        requestInformationContentSetMethod: "setContentFromParsable",
        queryParametersMapper: WithVaultIdAdvancedSearchRequestBuilderPostQueryParametersMapper,
    },
};
/* tslint:enable */
/* eslint-enable */
